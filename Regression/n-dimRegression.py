def lecture10():
    #Statistics meets Experimental Data
    import matplotlib.pyplot as plt
    import numpy, pandas, random
    def genNoisyParabolicData(a, b, c, xVals, fName):
        yVals = []
        for x in xVals:
            theorticalVal = a*x**2 + b*x + c
            yVals.append(theorticalVal+random.gauss(0, 35))
        f = open(fName, "w")
        f.write('x       y\n')
        for i in range(len(yVals)):
            f.write(str(yVals[i]) + ',' +str(xVals[i]) + '\n')
        f.close()
        
    xVals = range(-10, 11, 1)
    a, b, c = 3.0, 0.0, 0.0

    random.seed(0)
    genNoisyParabolicData(a, b, c, xVals, 'Dataset1.txt')
    genNoisyParabolicData(a, b, c, xVals, 'Dataset2.txt')
    #Data Generations is complete

    #Model Testing
    def rSquared(observed, predicted):
            error = ((predicted - observed)**2).sum()
            meanError = error/len(observed)
            return 1-(meanError/numpy.var(observed))
        
    def getData(fileName):
            dataFile = open(fileName, 'r')
            distances = []
            masses = []
            dataFile.readline() #reading the first line and discard it
            for line in dataFile:
                d, m = line.split(',')
                distances.append(float(d))
                masses.append(float(m))
            dataFile.close()
            return (masses, distances)

    def genFits(xVals, yVals, degrees):
            models = []
            for d in degrees:
                model = numpy.polyfit(xVals, yVals, d)
                models.append(model)
            return models

    def testFits(models, degrees, xVals, yVals, title):
            plt.plot(xVals, yVals, 'o', label = 'Data')
            for i in range(len(models)):
                estYVals = numpy.polyval(models[i], xVals)
                error = rSquared(yVals, estYVals)
                plt.plot(xVals, estYVals,
                           label = 'Fit of degree '\
                           + str(degrees[i])\
                           + ', R2 = ' + str(round(error, 5)))
            plt.legend(loc = 'best')
            plt.title(title)
            
            
    degrees = (2, 3, 4, 8, 16)
    xVals1, yVals1 = getData('Dataset1.txt')
    models1 = genFits(xVals1, yVals1, degrees)
    testFits(models1, degrees, xVals1, yVals1, 'Dataset1.txt')
    plt.figure()
    xVals2, yVals2 = getData('Dataset2.txt')
    models2 = genFits(xVals2, yVals2, degrees)
    testFits(models2, degrees, xVals2, yVals2, 'Dataset2.txt')
    #The overfitting that we just saw is generated from the training error
    #Small training error a necessary condition for a great, scalable model
    #We want model to work well on other data generated by the same process

    #Cross Validate Use models for Dataset 1 to predict Dataset2 and vice versa
    plt.figure()
    testFits(models1, degrees, xVals2, yVals2, 'DataSet 2/Model 1')
    plt.figure()
    testFits(models2, degrees, xVals1, yVals1, 'Dataset 1/Model 2')
    plt.show()
    #From this experimental plot, we see degree 2-4 are quite well fitting
    #not only on the training data but also on the testing data
    #Overfitting -- Fitting the underlying process and the internal noise 
    #For linear data predictive ability of first order fit
    #is much better than second order fit.
    #Our objective should be Balancing Fit with Complexity


    #Leave out one cross Validation -- For small dataset
    #leave one data out and create model using other vals, and test on left out value
    #Similarly for other values in the dataset

    #K fold Cross Validation
    #instead of leaving one out, just leave k sized group out
    #later use for testing

    #Random sampling Validation
    #Selecting some random n values (20%-30%)


    #Doing this complete predictionality

    #def lectureFittingTemperature():
    def rSquared(observed, predicted):
        error = ((predicted - observed)**2).sum()
        meanError = error/len(observed)
        return 1 - (meanError/numpy.var(observed))

    def genFits(xVals, yVals, degrees):
        models = []
        for d in degrees:
            model = numpy.polyfit(xVals, yVals, d)
            models.append(model)
        return models

    def testFits(models, degrees, xVals, yVals, title):
        plt.plot(xVals, yVals, 'o', label = 'Data')
        for i in range(len(models)):
            estYVals = plt.polyval(models[i], xVals)
            error = rSquared(yVals, estYVals)
            plt.plot(xVals, estYVals,
                       label = 'Fit of degree '\
                       + str(degrees[i])\
                       + ', R2 = ' + str(round(error, 5)))
        plt.legend(loc = 'best')
        plt.title(title)

    def getData(fileName):
        dataFile = open(fileName, 'r')
        distances = []
        masses = []
        dataFile.readline() #discard header
        for line in dataFile:
            d, m = line.split()
            distances.append(float(d))
            masses.append(float(m))
        dataFile.close()
        return (masses, distances)

    def labelPlot():
        pylab.title('Measured Displacement of Spring')
        pylab.xlabel('|Force| (Newtons)')
        pylab.ylabel('Distance (meters)')

    def plotData(fileName):
        xVals, yVals = getData(fileName)
        xVals = pylab.array(xVals)
        yVals = pylab.array(yVals)
        xVals = xVals*9.81  #acc. due to gravity
        pylab.plot(xVals, yVals, 'bo',
                   label = 'Measured displacements')
        labelPlot()

    def fitData(fileName):
        xVals, yVals = getData(fileName)
        xVals = pylab.array(xVals)
        yVals = pylab.array(yVals)
        xVals = xVals*9.81 #get force
        pylab.plot(xVals, yVals, 'bo',
                   label = 'Measured points')                 
        model = pylab.polyfit(xVals, yVals, 1)
        xVals = xVals + [2]
        yVals = yVals + []
        estYVals = pylab.polyval(model, xVals)
        pylab.plot(xVals, estYVals, 'r',
                   label = 'Linear fit, r**2 = '
                   + str(round(rSquared(yVals, estYVals), 5)))                
        model = pylab.polyfit(xVals, yVals, 2)
        estYVals = pylab.polyval(model, xVals)
        pylab.plot(xVals, estYVals, 'g--',
                   label = 'Quadratic fit, r**2 = '
                   + str(round(rSquared(yVals, estYVals), 5)))
        pylab.title('A Linear Spring')
        labelPlot()
        pylab.legend(loc = 'best')

    random.seed(0)

    class tempDatum(object):
        def __init__ (self, s):
            info = s.split(',')
            self.high = info[1]
            self.year = int(info[2][0:4])

        def getHigh(self):
            return self.high

        def getYear(self):
            return self.year

    def getTempData():
        inFile = open('temperatures.csv')
        data  = []
        for l in inFile:
            data.append(tempDatum(l))
        return data

    def getYearlyMeans(data):
        years = {}
        for d in data:
            try:
                years[d.getYear()].append(d.getHigh())
            except:
                years[d.getYear()] = [d.getHigh()]
        for y in years:
            years[y] = sum(years[y])/len(years[y])
        return years

    data =  getTempData()
    years= getYearlyMeans(data)
    xVals, yVals = [], []
    for e in years:
        xVals.append(e)
        yVals.append(years[e])
    plt.plot(xVals, yVals)
    plt.xlabel('Year')
    plt.ylabel('Mean daily high temperature')

    def splitData(xVals, yVals):
        toTrain = random.sample(range(len(xVals)), len(xVals)//2)
        trainX, trainY, testX, testY = [], [], [], []
        for i in range(len(xVals)):
            if i in toTrain:
                trainX.append(xVals[i])
                trainY.append(yVals[i])
            else:
                testX.append(xVals[i])
                testY.append(yVals[i])
        return trainX, trainY, testX, testY

    numSubsets = 10
    dimensions = (1, 2, 3, 4)
    rSquares = {}
    for d in dimensions:
        rSquares[d] = []
            
    for f in range(numSubsets):
        trainX, trainY, testX, testY = splitData(xVals, yVals)
        for d in dimensions:
            model = numpy.polyfit(trainX, trainY, d)
            estYVals = nunpy.polyval(model, trainX)
            estYVals = numpy.polyval(model, testX)
            rSquares[d].append(rSquared(testY, estYVals))
    print('Mean R-squares for test data')
    for d in dimensions:
        mean = round(sum(rSquares[d])/len(rSquares[d]), 4)
        sd = round(numpy.std(rSquares[d]), 4)
        print('For dimensionality', d, 'mean =', mean,
              'Std =', sd)
    print(rSquares[1])
